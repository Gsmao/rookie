###php引入文件方式和区别
1.include 包含并运行指定文件。  
++1：先按参数给出的路径寻找  
++2：如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找。  
++3：如果在 include_path 下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。  
++4：如果最后仍未找到文件则 include 结构会发出一条警告这一点和require不同，后者会发出一个致命错误  
++5：如果定义了路径——不管是绝对路径，还是当前目录的相对路径（以 . 或者 .. 开头）——include_path都会被完全忽略。  
2.include_once 只会包含一次。  
3.require  在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include只产生警告（E_WARNING），脚本会继续运行。  
4.require_once 只会包含一次。  

可以引入话题命名空间，use、php类的自动加载：  
1：除了比较老的代码逻辑，这种方式已经基本没人用了，现在框架一般都是用命名空间配合use关键字。use关键字他是延迟加载，等你要用到的时候才会去加载。  
2：一般框架中定义的autoload自动加载函数，会对名称进行处理，分析出类库名称所对应的文件路径，然后进行文件的加载。    
3：自己注册加载器，通过PSR规范自动加载，现在都是按照psr-4规范。  
4：psr-4简单来说就是按照物理路径去定义命名空间，还有其他的一些区分大小写之类的细节问题。自动加载器不能抛出异常。
5：php + composer.json真香，composer.json里面改好，跑一下命令就可以了。
(最早自己写项目的时候碰到过 class not found的问题，后来去参考了psr-4定义规范，在composer.json文件里面修改解决问题)


###cookie 和 session 区别
回答：因为http是无状态的，在交互式的网站中，如何进行有状态的交流，就提出了session。  
session是服务器方为了保存前面用户的一些信息，在下次请求中，去获取以前的信息。 然后把唯一标识 seesion_id 返回给客户端，客户端下次访问可以把这个信息传给后端用以解析。   

区别：  
1： session是一种抽象化的，就是存储在服务器上面的（也可以持久化到数据库，或者缓存里），cookie是http协议头里面的参数，key value形式  
2： cookie作用就是提供一个用户标识给后端，session作用就是识别这个标识，里面可以自己存储一些需要的用户信息。所以最大的区别就是一是存在客户端的，一个是服务端的  
3： cookie不安全，可以被解析出来用以代替。 安全方面考虑使用session。  
4： session的话相对于cookie服务器性能上面不如cookie  

扩展：cookie 和 session 就是一种交互方式，网上比较火的还有 jwt token   
jwt toekn: 就是客户端发起post请求，服务器通过加密创建一个jwt,返回给客户端，下次请求的时候把这个iwt传到后端，后端解析验证，返回请求资源。  
优点  
1.简洁, 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快  
2.负载中包含了所有用户所需要的信息，避免了多次查询数据库  
3.因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。  
4.不需要在服务端保存会话信息，特别适用于分布式微服务。  
5:单点登录（SSO）中比较广泛的使用了该技术。而且是加密的 没办法伪造 也很安全。

###php框架的了解和使用经验
框架模式知道哪些，基于MVC设计模式的，ORM 

我谈谈我对框架的理解，我刚入职的时候基本都是对着需求撸代码 什么OOP思想，框架，controller model service 根本不管，所有代码都撸到controller里面，
甚至controller里面裸写sql(历史遗留问题也有一部分，刚开始唯唯诺诺，只觉得乱，人家怎么来我就怎么来呗，后来越发的感觉这就是屎)

然后就开始接触一些mvc框架的概念，分了层次，从业务层到model层，感觉舒服了一些，复用性也很强。但是问题来了！！！
随着业务的迭代和发展，新的问题出现了，我见过一万行代码的model, 首先一个就是业务量大，再一个就是开发人员水平参差不齐，没有那种 OOP 编程思想，
数据库交互都是裸写一个sql，然后自己一个人用。

mvc的三层结构用起来还是很费劲，有的很多跟商品、优惠券、订单都扯一点关系的方法，那么这个写到那个model合适呢？业务更改怎么办呢？

自动加载 + 配置 + 路由 + redis/mysql加载 + MVC 架构 + ORM    
  
  
 
###CGI、FastCGI、php-fpm
### CGI
CGI 是Web Server 与 Web Application 之间数据交换的一种协议。
+ 把HTTP Request的Header设置成进程的环境变量。
+ HTTP Request的正文设置成进程的标准输入。
+ 而进程的标准输出就是HTTP Response包括Header和正文。

#####缺点：
+ 效率低下：每一个连接 fork 一个进程处理。
+ CGI只能收到一个请求，输出一个响应。

###FastCGI
FastCGI使用进程/线程池来处理一连串的请求。
这些进程/线程由FastCGI服务器管理，而不是Web服务器。 
当进来一个请求时，Web服务器把环境变量和这个页面请求通过一个Socket长连接传递给FastCGI进程。所以FastCGI有如下的优点：

+ 性能：通过进程/线程池规避了CGI开辟新的进程的开销。
+ 兼容：非常容易改造现有CGI标准的程序。
+ 语言无关：FastCGI是一套标准，理论上讲只要能进行标准输出（stdout）的语言都可以作为FastCGI标准的Web后端。

###php-fpm
+ PHP-FPM 是 PHP特有的，而FastCGI是一种标准，协议，跟语言无关。
+ PHP-FPM只是FastCGI的管理者；代替FastCGI负责处理web请求,也可以说php-fpm是fastcgi协议的实现，额外还提供了相对智能一些任务管理。
  + 比如说php的静态模式和动态模式，php-fpm的进程数可以根据设置分为动态和静态。  
  1. 静态：直接开启指定数量的php-fpm进程，不再增加或者减少；
  2. 动态：开始的时候开启一定数量php-fpm进程，当请求变大的时候，动态的增加php-fpm进程数到上限，当空闲的时候自动释放空闲进程数到一个下限。
  
### 抽象类 && 接口
#### 抽象类与接口的相同点：
1. 都是用于声明某一种事物，规范名称、参数，形成模块，无实现细节。  
2. 都是通过类来实现相关的细节工作  
3. 不能有方法体，即｛｝符号  
4. 都可以用继承，接口可以继承接口形成新的接口，抽象类可以继承抽象类从而形成新的抽象类
  
#### 抽象类与接口的不同点：  
1. 抽象类可以有属性变量，接口不能，只有常量  
2. 抽象类内未必有抽象方法，但接口内一定会有“抽象”方法    
3. 抽象类用abstract关键字在类前声明，且有class声明为类，接口是用interface来声明，但不能用class来声明，因为接口不是类。  
4. 抽象类的抽象方法一定要用 abstract 来声明，而接口则不需要  
5. 抽象类是用：extends 关键字继承。 而接口则是用 implements，且接口可以一次性实现多个方法，用逗号分开各个接口就可。(PHP里面只有单继承)
  
#### 各自的特点：  
1. 抽象类内未必有抽象方法，但有抽象方法的类，则必是抽象类  
2. 抽象类内，即便全是具体方法，也不能够实例化，只要新建类来继承后，实例继承类才可以  
3. 接口可以让一个类一次性实现多个不同的方法  
4. 接口本身就是抽象的，但注意不是抽象类，因为接口不是类，只是其方法是抽象的。所以，其也是抽象的  